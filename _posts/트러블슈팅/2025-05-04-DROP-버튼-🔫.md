---
categories: [트러블슈팅]
tags: [troubleshooting]
published: false
---

## 버그 원인 파악 및 해당 버그 해결해보기

과제를 진행하며 정말 많은 버그들을 마주했지만 그 중 하나를 소개해보고자 한다.

### 사건

사건은 7주차 과제가 요하는 최소 요건을 만족하고 나서 일어났다.  
해당 과제의 완성도를 조금이나마 더 높이고자 하여 버그가 발생할 만한 부분을 여러 조건으로 테스트 했다.  
내가 발견한 것은 전부터도 계속 거슬렸던 부분이었다.  
해당 부분은 바로 “조작하고 있는 버튼에서 마우스나 터치가 벗어났을 때”였다.  
아래 영상이 내가 고치고자 하는 버그였다.  
커서의 위치를 집중적으로 확인해보자.  

<video src="/assets/img/troubleshooting-14.mov" controls style="max-width: 100%; height: auto;"></video>

위에서 보다시피 버튼을 누르는 중간에 해당 버튼을 커서가 벗어나면 손가락을 떼어도 해당 동작  
인식을 하지 못해 계속해서 떨어지며 버튼을 재차 눌러도 계속해서 떨어지는 버그를 발견하였다.

### 의사코드

- 버튼에는 누르고 있을 때와 떼었을 때만을 인식한다.
- 버튼을 누르고 있는 중 버튼 영역을 벗어났을 때도 인식하게 한다.
- 벗어났을 때를 인식하여 버튼을 누르던 중 떼었을 때와 같은 동작을 하게 한다.

우선 위 중심으로 맥 브라우저에서의 동작 구현부터 해보고 모바일은 이후에 하기로 했다.

#### 추가 버그 발생 지점 1

- 눌렀을 때는 `onMouseDown`과 `onTouchStart`,
- 떼었을 때는 `onMouseUp`과 `onTouchEnd`를 사용하였는데
- 여기서 `onMouseOut`을 추가한다.
    
    ```jsx
    <button
          id="droppingButton"
          className={`fixed`}
          style={preventDownload}
          onMouseDown={handleMouseDown}
          onTouchStart={handleMouseDown}
          onMouseUp={handleMouseUp}
          onTouchEnd={handleMouseUp}
          
          onMouseOut={handleMouseUp} // 추가
          
        >
          DROP
        </button>
    ```
    
    위 기능을 추가하고 테스트를 해보았다.
    
    <video src="/assets/img/troubleshooting-15.mov" controls style="max-width: 100%; height: auto;"></video>
    
    내가 의도한 대로 마우스가 버튼 영역을 벗어났을 때 이를 감지하여  
    실패 처리를 하는 것을 확인할 수 있었다!  
    하지만 또 다른 버그가 발생했다.
    
    <video src="/assets/img/troubleshooting-16.mov" controls style="max-width: 100%; height: auto;"></video>
    
    버튼을 누르고 게임을 시작도 안했는데 그저 커서가 해당 버튼 영역을  
    벗어나기만 하면 실패 처리하는 것을 알 수 있었다..
    

#### 추가 버그 발생 지점 2

버튼에 해당 `onMouseOut` 기능을 넣어주게 되면 언제든지 영역을 벗어날 때마다  
해당 기능을 실행시킬 것으로 생각됐다.  
그렇기 때문에 특정 조건에만 위 기능을 동작하게 해야했고  
해당 조건은 바로 “버튼이 눌렸을 때”만 이를 감지하면 됐다.

그렇기 때문에 버튼의 `onMouseDown`일 때 실행시킬 `handleMouseDown` 코드 내에,

```jsx
<button
      id="droppingButton"
      className={`fixed`}
      style={preventDownload}
      onMouseDown={handleMouseDown}
      onTouchStart={handleMouseDown}
      onMouseUp={handleMouseUp}
      onTouchEnd={handleMouseUp}
    >
      DROP
    </button>
```

```jsx
  const handleMouseDown = () => {
     
     ... "사과 떨어트리는 로직" ...

    const dropButton = document.getElementById("droppingButton");
    dropButton.addEventListener("mouseout", () => {
      clearInterval(id);
      setIntervalId(null);
      showDropButton(false);
      chooseSuccessOrNot("FAIL");
      showResultModal(true);
    });
  };
```

**버튼이 눌려있을 때** 버튼 요소를 `getElementById`를 통해 가져오고 해당 버튼에 `mouseout`이라는 이벤트를  
`addEventListner`를 통해 넣어주어 커서가 버튼 영역을 벗어났을 때 안의 기능을 실행시켜 주었다.

<video src="/assets/img/troubleshooting-17.mov" controls style="max-width: 100%; height: auto;"></video>

위처럼 아무 때나 mouseOut이 일어나는 버그는 해결했지만.

<video src="/assets/img/troubleshooting-18.mov" controls style="max-width: 100%; height: auto;"></video>

이번에는 순조롭게 내려가다가 이상한 지점에서 자동적으로 실패 처리가
되는 것을 확인했다.

### 발전

도저히 코드만 봐서는 어디서 어떤 이유로 버그가 일어나는 지 확인할 수가 없어 `debugger` 를 사용했다.

![스크린샷 2025-05-02 오후 2.25.28.png](/assets/img/troubleshooting-19.png)

커서가 계속 버튼 영역 내에 있었음에도 불구하고 `mouseout`이 실행되었고 실행시킬 함수 내에 `debugger` 또한  실행되었다. 

그런데 `debugger`가 실행되는 시점의 게임 화면을 보았을 때 힌트를 얻을 수 있었다.  
버튼이 도착선 밑으로 내려가 가려지는 것을 볼 수 있다.  
내가 추론한 것은 버튼이 도착선에 가까워지면서 도착선에 가려지게 되고,  
“`mouseout` 이벤트는 이 또한 버튼 영역에서 벗어났다고 판단하여 이벤트를 발생시킨다”였다.  
그렇기 때문에 버튼 요소의 `z-index`를 높은 값으로 주어 도착선에 가려지지 않게 만들어 보았다.

### 대망의 결과

<video src="/assets/img/troubleshooting-20.mov" controls style="max-width: 100%; height: auto;"></video>


<video src="/assets/img/troubleshooting-21.mov" controls style="max-width: 100%; height: auto;"></video>

위처럼 깔끔하게  
 *”커서가 버튼 영역을 벗어났을 때 자동 실패 처리”*와  
*“도착선 부근에서 일어나는 자동 실패 버그”*를 해결할 수 있었다.

마지막 버그에 대해서는 코드 적으로 해당 지점에서 멈출 요인이 없어보여서  
꽤나 오랫동안 곯머리를 알았는데 단순히 css 요소인 `z-index`의 이유로 인한  
버그였다는 것을 알게되니 허탈했다.

하지만 버그를 해결하는 과정 중에 발생 지점, 발생 요인 등을 관철하고 추론하는 것에  
조금 더 익숙해지는 계기가 되었다.

## 성공!